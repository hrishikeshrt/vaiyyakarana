#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan  1 11:18:04 2021

@author: Hrishikesh Terdalkar


Python Wrapper for Inria Heritage Platform

Can query through web mirror and unix shell

UNIX Shell
- Heritage_Platform/ML/ contains the scripts
- export QUERY_STRING as shell variable
  (referred to as OPTION_STRING in this code alongwith the '&text=TEXT' part)
- execute various scripts, such as ./reader
- still produces HTML output that needs to be parsed


# Default input needs to be in the devanagari format
# HeritagePlatform.dn2vh() function will convert this to VH

# TODO: Windows Compatibility
    * SIGALRM
    * subprocess
"""

import os
import re
import time
import random
import signal
import logging
import requests
import subprocess
import urllib.parse

from bs4 import BeautifulSoup

from logger import setup_logger

scriptname, _ = os.path.splitext(os.path.basename(__file__))
setup_logger('heritage', f'{scriptname}.log')
log = logging.getLogger('heritage')

###############################################################################


def timeout_handler(signum, frame):
    raise TimeoutError("Time limit exceeded.")


signal.signal(signal.SIGALRM, timeout_handler)


###############################################################################

HERITAGE_LANG = {
    'gender': {
        'm': 'पुंलिङ्गम्',
        'f': 'स्त्रीलिङ्गम्',
        'n': 'नपुंसकलिङ्गम्'
    },
    'case': {
        'nom': 'प्रथमा',
        'acc': 'द्वितीया',
        'i': 'तृतीया',
        'dat': 'चतुर्थी',
        'abl': 'पञ्चमी',
        'g': 'षष्ठी',
        'loc': 'सप्तमी',
        'voc': 'सम्बोधनम्'
    },
    'number': {
        'sg': 'एकवचनम्',
        'du': 'द्विवचनम्',
        'pl': 'बहुवचनम्'
    }
}

###############################################################################


class HeritageOutput:
    """
    Heritage Output Parser

    Parse output generated by various utilities from Heritage Platform
    """
    CLASSES = {
        'footer': ['enpied']
    }

    def __init__(self, html):
        self.html = html
        self.soup = BeautifulSoup(html, 'html.parser')
        self.process()

    def process(self, html=None):
        """Process the html and extract basic information"""
        # Allow re-using of the class
        if html is not None:
            self.html = html
            self.soup = BeautifulSoup(html, 'html.parser')

        self.body = self.soup.find('body')
        self.footer = self.body.find('div', class_=self.CLASSES['footer'])

        # Extract Meta Information
        self.meta = {}
        for meta in self.soup.find_all('meta'):
            if meta.get('name', ''):
                self.meta[meta.get('name')] = meta.get('content', '')
            if meta.get('property', ''):
                self.meta[meta.get('property')] = meta.get('content', '')

        # Extract Title
        self.title = self.soup.find('title')
        self.inner_title = self.body.find('h1', class_='title')

        # Find Relevant Body Children
        self.blocks = self.body.find_all()

    def extract_analysis(self):
        if self.title.text != 'Sanskrit Reader Companion':
            log.error("Invalid output page.")
            return None

        hr_blocks = self.html.split('<hr>')
        if len(hr_blocks) < 2:
            log.error("No solutions found.")
            return None

        solutions = []
        for block in hr_blocks[2:]:
            if 'Solution' not in block:
                break

            solution = {}

            soup = BeautifulSoup(block, 'html.parser')
            first_span = soup.find('span')

            solution['id'] = int(first_span.text.split()[1])
            solution['words'] = []

            tables = soup.find_all('table')
            for table in tables:
                if table.find('table'):
                    word = {}
                    word['text'] = table.previous_sibling.get_text()
                else:
                    # Inner table contains analysis and it occurs after
                    # the original word
                    word.update(self.parse_analysis(table.get_text()))
                    word['classes'] = table.get('class', [])
                solution['words'].append(word)

            solutions.append(solution)
        return solutions

    @staticmethod
    def parse_analysis(text):
        pattern = r'^\[([^\]]*)\]\{([^\}]*)\}$'
        match = re.search(pattern, text.strip(), flags=re.DOTALL)
        analysis = {}
        if match:
            print(text, match.groups())
            analysis['root'] = match.group(1)
            analysis['analyses'] = match.group(2).split('|')
        return analysis

    def __repr__(self):
        return repr(self.soup)

###############################################################################


class HeritagePlatform:
    """
    Heritage Platform

    Python wrapper for using various utilities from INRIA Heritage Platform
    """

    INRIA_URL = 'https://sanskrit.inria.fr/cgi-bin/SKT/'
    ACTIONS = {
        'reader': {
            'shell': 'reader',
            'web': 'sktreader.cgi'
        },
        'search': {
            'shell': 'indexer',
            'web': 'sktindex.cgi'
        },
        'declension': {
            'shell': 'declension',
            'web': 'sktdeclin.cgi'
        },
        'conjugation': {
            'shell': 'conjugation',
            'web': 'sktconjug.cgi'
        },
        'lemma': {
            'shell': 'lemmatizer',
            'web': 'sktlemmatizer.cgi'
        }
    }
    METHODS = ['shell', 'web']

    def __init__(self, repo_dir, base_url=None, method='shell', font='deva'):
        """
        Initialize Heritage Class

        Parameters
        ----------
        repo_dir : str
            Path to the Heritage_Platform repository.
            The directory should contain 'ML' sub-directory,
            which further contains the scripts
        base_url : str, optional
            URL for the Heritage Platform Mirror.
            If None, the official INRIA website will be used.
            The default is None.
        method : str, optional
            Method used to obtain results. Results can be obtained either using
            the web installation or using UNIX shell.

            Possible values are, 'shell' and 'web'
            The default is 'shell'.
        """
        self.base_url = self.INRIA_URL if base_url is None else base_url
        self.base_dir = repo_dir
        self.scripts_dir = os.path.join(self.base_dir, 'ML')
        self.method = None
        self.font = None

        self.set_method(method)
        self.set_font(font)

    ###########################################################################
    # Utilities (Actions)

    def get_analysis(self, input_text, word=True):
        """
        Utility to obtain morphological analyses using Reader Companion

        Returns
        -------
        result : list
            List of valid morphological analyses
        """
        opt_st = 'f' if word else 't'
        options = {
            'lex': 'MW',   # Lexicon (MW) Monier-Williams (SH) Heritage
            'cache': 't',  # Use Cache (t)rue, (f)alse
            'st': opt_st,  # Sentence (t)rue, Word (f)alse
            'us': 't',     # Unsandhied (t)rue, (f)alse
                           # if 'us' is 'f', "ca eva" is parsed as "ca_eva",
                           # "tathā eva" as "tathā_eva" etc.
            'cp': 't',     # Full Parser Strength (t)rue, (f)alse
            't': 'VH',     # Transliteration Scheme (Must be VH)
            'mode': 'p',   # Parse Mode (p)arse, (g)raph, (s)ummary
            'font': self.font,
                           # Output Display Font (deva)nagari (roma)n
            'topic': '',
            'corpmode': '',
            'corpdir': '',
            'sentno': '',
            'text': self.prepare_input(input_text)
        }
        result = self.get_result('reader', options)
        output = HeritageOutput(result)

        return output

    # ----------------------------------------------------------------------- #

    def search_lexicon(self, word, lexicon='MW'):
        """
        Search a word in the dictionary

        Parameters
        ----------
        word : str
            Sanskrit Word to search (in Devanagari)
        lexicon : str, optional
            Lexicon to search the word in.
            Possible values are,
                * MW: Monier-Williams Dictionary
                * SH: Heritage Dictionary
            The default is 'MW'.

        Returns
        -------
        matches : list
            List of matches.
        """
        options = {
            'lex': lexicon,
            't': 'VH',
            'q': self.prepare_input(word),
            'font': self.font
        }
        result = self.get_result('search', options)
        output = HeritageOutput(result)

        return output

    # ----------------------------------------------------------------------- #

    def search_inflected_form(self, word, category):
        """
        Search an inflected form

        Parameters
        ----------
        word : str
            Sanskrit Word to search (in Devanagari)
        category : str
            Type of the word
                * Noun: Noun
                * Pron: Pronoun
                * Part: Participle
                * Inde: Indeclinible
                * Absya, Abstvaa, Voca, Iic, Ifc, Iiv, Piic etc.
        Returns
        -------
        matches : list
            List of matches.
        """
        options = {
            't': 'VH',
            'q': self.prepare_input(word),
            'c': category,
            'font': self.font
        }
        result = self.get_result('lemma', options)
        output = HeritageOutput(result)

        return output

    # ----------------------------------------------------------------------- #

    def get_word_forms(self, word, gender, lexicon='MW'):
        options = {
            'lex': lexicon,
            't': 'VH',
            'q': self.prepare_input(word),
            'g': self.identify_gender(gender),
            'font': self.font
        }
        result = self.get_result('declension', options)
        output = HeritageOutput(result)

        return output

    # ----------------------------------------------------------------------- #

    def get_verb_forms(self, word, gana, lexicon='MW'):
        options = {
            'lex': lexicon,
            't': 'VH',
            'q': self.prepare_input(word),
            'c': gana,
            'font': self.font
        }
        result = self.get_result('conjugation', options)
        output = HeritageOutput(result)

        return output

    ###########################################################################
    # Fetch Result through Web or Shell

    def get_result_from_web(self, url, options, attempts=3):
        """
        Get results from the Heritage Platform web mirror
        Exponential backoff is used in case there are network errors

        Parameters
        ----------
        url : str
            URL of the CGI script to call
            HeritagePlatform.get_url() can be used to generate supported URLs
        options : dict
            Dictionary containing valid options for the script
        attempts : int, optional
            Number of attempts for the exponential backoff
            The default is 3.

        Returns
        -------
        str
            Result (HTML) obtained
        """

        query_string = '&'.join([f'{k}={v}' for k, v in options.items()])
        query_url = f'{url}?{query_string}'

        # query with exponential-backoff
        r = requests.get(query_url)

        if r.status_code != 200:
            for n in range(attempts):
                if n == 0:
                    print(f"QUERY_URL: {query_url}")
                    log.warning(f"URL: {query_url}")

                log.warning(f"Status Code: {r.status_code} (n = {n})")
                print(f"Status Code: {r.status_code}. (n = {n})")

                fn = n
                backoff = (2 ** fn) + random.random()
                time.sleep(backoff)
                r = requests.get(query_url)

                if r.status_code == 200:
                    log.info(f"Resolved! (n = {n})")
                    print(f"Resolved! (n = {n})")
                    break
            else:
                log.warning(f"Failed on '{query_url}' after {n} attempts.")
                print(f"Failed on '{query_url}' after {n} attempts.")

        return r.text

    # ----------------------------------------------------------------------- #

    def get_result_from_shell(self, path, options, timeout=15):
        """
        Get results from the Heritage Platform's local installation via shell

        Parameters
        ----------
        path : str
            Path to the executable script
            HeritagePlatform.get_path() can be used to generate supported paths
        options : dict
            Valid options for the script
        timeout : int, optional
            Timeout in seconds, after which the function will abort.
            The default is 15.

        Returns
        -------
        result : str
            Result (HTML) obtained
        """
        query_string = '&'.join([f'{k}={v}' for k, v in options.items()])
        environment = {'QUERY_STRING': query_string}
        signal.alarm(timeout)
        try:
            result_header = 'Content-Type: text/html\n\n'
            result = subprocess.check_output(
                path, env=environment
            ).decode('utf-8')
            result = result[len(result_header):]
        except TimeoutError:
            log.error("TimeoutError")
            return None
        signal.alarm(0)
        return result

    # ----------------------------------------------------------------------- #

    def get_result(self, action, options, *args, **kwargs):
        """
        High-level function to obtain result for various actions

        Avoids the hassle of generating the URL or PATH.
        Utilizes the HeritagePlatform.method attribute to determine
        whether to fetch through shell or web.

        Parameters
        ----------
        action : str
            Action value corresponding to the utility to be used.
            Refer to HeritagePlatform.ACTIONS
        options : dict
            Valid options for the specified action

        Returns
        -------
        str
            Result (HTML) obtained
        """
        if self.method == 'shell':
            path = self.get_path(action)
            return self.get_result_from_shell(path, options, *args, **kwargs)
        if self.method == 'web':
            url = self.get_url(action)
            return self.get_result_from_web(url, options, *args, **kwargs)
        log.error(f"Invalid method: '{self.method}'.")

    ###########################################################################

    def set_method(self, method):
        """
        Set method for fetching the output

        Valid methods are listed in HeritagePlatform.METHODS
        """
        if method.lower() in self.METHODS:
            self.method = method.lower()
            return True
        log.warning(f"Invalid method: '{method}'")
        if self.method is None:
            self.method = 'shell'
        return False

    def set_font(self, font):
        """
        Set the font for Sanskrit output

        Valid fonts are,
            * deva: Devanagari
            * roma: Roman (IAST)
        """
        if font.lower() in ['deva', 'roma']:
            self.font = font.lower()
            return True
        log.warning(f"Invalid font: '{font}'")
        if self.font is None:
            self.font = 'deva'
        return False

    ###########################################################################
    # URL or Path Builders

    def get_url(self, action):
        """URL Builder"""
        return urllib.parse.urljoin(self.base_url, self.ACTIONS[action]['web'])

    def get_path(self, action):
        """Path Builder"""
        return os.path.join(self.scripts_dir, self.ACTIONS[action]['shell'])

    ###########################################################################

    def __repr__(self):
        params = {
            'repository': self.base_dir,
            'url': self.base_url,
            'method': self.method,
            'font': self.font
        }
        repr_params = ', '.join([f'{k}="{v}"' for k, v in params.items()])
        return f'{self.__class__.__name__}({repr_params})'

    ###########################################################################

    def prepare_input(self, input_text):
        """
        Prepare Input
            * Convert Devanagari to Velthuis
            * Join words by '+' instead of by whitespaces
        """
        return '+'.join(self.dn2vh(input_text).split())

    @staticmethod
    def identify_gender(gender):
        genders = {
            'Mas': ['पु', 'm'],
            'Fem': ['स्त्री', 'f'],
            'Neu': ['नपु', 'n'],
            'Any': ['*', 'a']
        }
        for gender_key, gender_list in genders.items():
            for g in gender_list:
                if gender.lower().startswith(g):
                    return gender_key

    @staticmethod
    def dn2vh(text):
        """
        Convert Devanagari to Velthuis

        Heritage Platform uses its own DN to VH conversion
        This deviates from the standard one (from Wiki or other sources)
        Following is a translation of the JS function convert() from the
        Heritage Platform
        Source URL: http://hrishirt.cse.iitk.ac.in/heritage/DICO/utf82VH.js
        """

        inHex = ["05", "06", "07", "08", "09", "0a", "0b", "60", "0c", "0f",
                 "10", "13", "14", "02", "01", "03", "3d", "4d"]
        outVH = ["a", "aa", "i", "ii", "u", "uu", ".r", ".rr", ".l", "e", "ai",
                 "o", "au", ".m", "~l", ".h", "'", ""]
        matIn = ["3e", "3f", "40", "41", "42", "43", "44", "62", "47", "48",
                 "4b", "4c"]
        consIn = ["15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e",
                  "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28",
                  "2a", "2b", "2c", "2d", "2e", "2f", "30", "32", "35", "36",
                  "37", "38", "39", "00"]

        orig = text
        output = ''
        wasCons = False

        for i in range(len(orig)):
            origC = orig[i]
            hexcode = hex(ord(origC)).lstrip('0x')
            lenL = len(hexcode)
            hexcode = '0' * (4 - lenL) + hexcode

            check = hexcode[2:]
            init = hexcode[:2]

            if init != '09':
                check = '00'
            consOut = ["k", "kh", "g", "gh", "f", "c", "ch", "j", "jh", "~n",
                       ".t", ".th", ".d", ".dh", ".n", "t", "th", "d", "dh",
                       "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "v", "z",
                       ".s", "s", "h", origC + ""]

            for j in range(len(inHex)):
                if check == inHex[j]:
                    if check in ["01", "02", "03", "3d"]:
                        if wasCons:
                            output += "a" + outVH[j]
                        else:
                            output += outVH[j]
                    else:
                        output += outVH[j]
                    wasCons = False

            for j in range(len(consIn)):
                if check == consIn[j]:
                    if wasCons:
                        output += "a" + consOut[j]
                    else:
                        output += consOut[j]
                    wasCons = (check != '00')
                    if i == len(orig) - 1:
                        output += "a"
            for j in range(len(matIn)):
                if check == matIn[j]:
                    output += outVH[j+1]
                    wasCons = False

        return output

###############################################################################
